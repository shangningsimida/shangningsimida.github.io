<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://shangningsimida.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="shangningsimida">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://shangningsimida.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-算法报告" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/31/%E7%AE%97%E6%B3%95%E6%8A%A5%E5%91%8A/" class="article-date">
  <time class="dt-published" datetime="2021-01-31T06:03:32.308Z" itemprop="datePublished">2021-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="算法学习报告"><a href="#算法学习报告" class="headerlink" title="算法学习报告"></a>算法学习报告</h1><p>（1.24-1.31）<br>#define SIZE_OF_ARRAY(x) (sizeof(x) / sizeof(x[0]))</p>
<p>void swap(int &amp;a,int &amp;b)<br>{<br>    int tmp = a;<br>    a = b;<br>    b = tmp;<br>}</p>
<p>#define OUT_PUT_DEBUG_ARRAY(x,len) do <br>{<br>    for (int i = 0; i &lt; len; i++)<br>    {<br>        printf(“%6d”,x[i]);<br>    }<br>    printf(“\r\n————————–\r\n”);<br>} while (0);</p>
<p>// 0.冒泡排序<br>// 从头开始，依次遍历所有元素，当遇到比当前元素小的，直接交换<br>void BubbleSort_Wrong(int *arr, int len)<br>{<br>    for (int i = 0; i &lt; len - 1; ++i)<br>    {<br>        for (int j = i + 1; j &lt; len; ++j)<br>        {<br>            if (arr[i] &gt; arr[j])<br>            {<br>                swap(arr[i], arr[j]);<br>            }<br>        }<br>    }<br>}</p>
<p>void BubbleSort_Right(int *arr, int len)<br>{<br>    for (int i = 0; i &lt; len - 1; ++i)<br>    {<br>        int nMax = arr[i];<br>        for (int j = 0; j &lt; len - 1 - i; ++j)<br>        {<br>            if (arr[j + 1] &gt; arr[j])<br>            {<br>                swap(arr[j + 1], arr[j]);<br>            }<br>        }<br>    }<br>}</p>
<p>// 1.选择排序<br>// 从头开始，依次遍历所有元素，找出当前坐标到结尾最小的元素，进行交换<br>// 思想与冒泡排序差不多，只不过交换放到了循环外，减少了交换次数<br>void SelectSort(int *arr, int len)<br>{<br>    for (int i = 0;i &lt; len - 1;++i)<br>    {<br>        int k = i;<br>        for (int j = i + 1;j &lt; len;++j)<br>        {<br>            //if (arr[i] &gt; arr[j]) – 此处错误，多谢指正@_@ @tuohaohu<br>            if (arr[k] &gt; arr[j])<br>            {<br>                k = j;<br>            }<br>        }<br>        if (i != k)<br>        {<br>            swap(arr[i], arr[k]);<br>        }<br>    }<br>}</p>
<p>// 2.插入排序<br>// 总所周知，当只有一个元素时，待排数据为有序数据<br>// 假定数组arr[n]，当 0 &lt; k &lt; n时，a[0]<del>a[k-1]有序，a[k]</del>a[n-1]无序<br>// 此时，将arr[k]拿出来，将arr[0]<del>arr[k-1]从k-1开始往左遍历，如果a[j] &gt; a[k]，则将a[j]左移，指导a[j] &lt; a[k]，此时将a[k]放到a[j+1]，arr[0]</del>arr[k]变为有序序列<br>// 当遍历晚arr[n]时，此时数据将为有序序列<br>void InsertSort(int *arr, int len)<br>{<br>    if (len &lt;= 1)<br>    {<br>        return;<br>    }</p>
<pre><code>for (int i = 1; i &lt; len;++i)
&#123;
    int tmp = arr[i];
    for (int j = i - 1;j &gt;= 0;--j)
    &#123;
        if (arr[j] &gt;= tmp)
        &#123;
            arr[j + 1] = arr[j];
        &#125;
        else
        &#123;
            arr[j + 1] = tmp;
            break;
        &#125;
    &#125;
&#125;</code></pre>
<p>}</p>
<p>// 3.二分插入排序<br>// 因为直接插入排序在搜索插入位置的时候，效率很低，对于大数组，尤其不适用<br>// 于是采用二分插入排序，又叫折半插入排序， 二分插入排序是采用折半查找法寻找要插入的位置<br>// 二分搜索：<br>void  BinaryInsertSort(int *arr, int len)<br>{<br>    for (int i = 1; i &lt; len; ++i)<br>    {<br>        int tmp = arr[i];<br>        int iHigh = i - 1;<br>        int iLow  = 0;<br>        int iMid = 0;<br>        while (iLow &lt;= iHigh)<br>        {<br>            iMid = (iLow + iHigh) / 2;<br>            if (tmp &gt; arr[iMid] )<br>            {<br>                iLow = iMid + 1;<br>            }<br>            else<br>            {<br>                iHigh = iMid - 1;<br>            }<br>        }</p>
<pre><code>    // 将 iMid 到 i 的数据左移
    for (int j = i; j &gt; iMid; --j)
    &#123;
        arr[j] = arr[j - 1];
    &#125;
    arr[iLow] = tmp;
&#125;</code></pre>
<p>}</p>
<p>// 4.归并排序<br>// 将待排序数据，从中间分为2段A和B，使A和B分别有序后，再将A和B使用插入排序<br>// 退出条件为<br>void MergeSort(int *arr, int beg,int end)<br>{<br>    //OUT_PUT_DEBUG_ARRAY(&amp;arr[beg], end - beg);<br>    if (beg &gt;= end)<br>    {<br>        return;<br>    }</p>
<pre><code>if (beg == end - 1)
&#123;
    if (arr[beg] &gt; arr[beg + 1])
    &#123;
        swap(arr[beg], arr[beg + 1]);
    &#125;    
    return;
&#125;

// 将beg到end分为2段A和B，并将A和B分别使用归并排序
int iL1 = beg;
int iH1 = (beg + end) / 2;
int iL2 = iH1 + 1;
int iH2 = end;
MergeSort(arr, iL1, iH1);
MergeSort(arr, iL2, iH2);

// 将A 和 B 排序完毕后，合并A和B——使用插入排序 
for (int i = iL2; i &lt;= iH2; ++i)
&#123;
    int tmp = arr[i];
    for (int j = iH1 + i - iL2; j &gt;= iL1; --j)
    &#123;
        arr[j + 1] = arr[j];
        if (tmp &gt; arr[j])
        &#123;
            arr[j + 1] = tmp;
            break;
        &#125;
    &#125;
&#125;</code></pre>
<p>}</p>
<p>// 5.快速排序<br>// 1.以左右两端i和j为起点，从右往左开始，找到比最左端小的数,停止坐标记为A，从左往右找到比最左端大的数，停止坐标记为A。交换A和B标记的数。<br>// 2.重复第一点，直到A == B，将此事的坐标所标识的值与最开始的数据交换。记此时的坐标为K<br>// 3.分别对 i~K-1 与 K+1 ~ j 重复上诉1、2两点<br>void quickSort(int *arr, int left, int right)<br>{<br>    if (left &gt; right)<br>    {<br>        return;<br>    }</p>
<pre><code>int tmp = arr[left];
int iLeft = left;
int iRight = right;
while (left != right)
&#123;
    while (right &gt; left &amp;&amp; (arr[right] &gt;= tmp))
    &#123;
        right--;
    &#125;
    while (right &gt; left &amp;&amp; (arr[left] &lt;= tmp))
    &#123;
        left++;
    &#125;
    if (left &lt; right)
    &#123;
        swap(arr[left], arr[right]);
    &#125;        
&#125;


arr[iLeft] = arr[left];
arr[left] = tmp;

quickSort(arr, iLeft, left - 1);
quickSort(arr, left + 1, iRight);</code></pre>
<p>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shangningsimida.github.io/2021/01/31/%E7%AE%97%E6%B3%95%E6%8A%A5%E5%91%8A/" data-id="ckkkqujb500016kvf4ign2g4o" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linux学习报告" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/31/linux%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/" class="article-date">
  <time class="dt-published" datetime="2021-01-31T06:01:03.091Z" itemprop="datePublished">2021-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="linux学习报告"><a href="#linux学习报告" class="headerlink" title="linux学习报告"></a>linux学习报告</h1><p>（1.24-1.31）<br>1.常见操作系统</p>
<ul>
<li>服务端操作系统 ： linux、unix、windows server </li>
<li>单机操作系统 ： windows（dos 、ucdos、win95、win98、win2000、xp、vista、win7、win8）<pre><code>            MAC 、linux（ubuntu）</code></pre>
</li>
<li>移动操作系统 Android、IOS 、Windows phone</li>
</ul>
<p>2.linux操作系统介绍</p>
<ul>
<li>为什么要学习linux操作系统 <ol>
<li>大部分服务端都采用linux ，JEE部署到服务器中</li>
<li>一些企业和学校采用linux研发和教学 </li>
</ol>
</li>
</ul>
<ol start="3">
<li>很多嵌入式开发 用linux  <ol start="4">
<li>云计算、大数据 是集群网  linux : centos </li>
</ol>
</li>
</ol>
<ul>
<li>特点   <ol>
<li>开放、开源、多用户的网络操作系统</li>
</ol>
</li>
</ul>
<ol start="2">
<li>基于unix（unix–&gt;minix–&gt;linux(linus :林纳斯 芬兰 )），可以定制内核</li>
<li>假如了GNU组织（自由软件组织 ，copyLeft） ，通过GPL（通用公共许可） 许可对外发布  </li>
</ol>
<ul>
<li>linux组成<ol>
<li>linux内核（linus 团队管理）</li>
</ol>
</li>
</ul>
<ol start="2">
<li>shell ：用户与内核交互的接口</li>
<li>文件系统 ： ext3、ext4 等  windows 有 fat32  、ntfs </li>
<li>第三方应用软件 </li>
</ol>
<ul>
<li>linux操作系统版本   <ol>
<li>内核版本 (linus 团队管理)  3.8</li>
</ol>
</li>
</ul>
<ol start="2">
<li>发行版本  :一些软件公司以内核为基础，再添加一些软件和文档形成发行版本<ul>
<li>red hat  ： rhel ，centos</li>
<li>debian   ： debian，ubuntu（桌面）</li>
<li>android<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>二.安装linux系统</li>
</ul>
</li>
</ol>
<p>vmware安装 ： 创建虚拟机的软件<br>vitual box ：oracle 公司提供</p>
<p>虚拟机安装</p>
<p>直接安装<br>创建虚拟机<br>安装ubuntu镜像<br>打开虚拟机镜像： 虚拟机+操作系统（ubuntu）<br>打开*.vmx 文件<br>用户名 itcast 密码 123<br>三.linux系统环境<br>默认有6个命令交互通道和一个图形界面交互通道，默认进入到的是图形界面通道<br>命令交互模式切换：ctrl+alt+f1—f6<br>图形交互界面 ctrl+alt+f7</p>
<p>1.图形界面交互模式</p>
<ul>
<li>terminal： 图形界面的命令终端，它是图形界面交互通道的延伸，要依赖于图形界面</li>
</ul>
<p>2.命令交互模式<br>命令提示符：<br>itcast@ubuntu:~−itcast：用户名−ubuntu：主机名− ：路径，假如当前的路径正好是该用户存放数据的根目录，则显示 − :用户的类型 $代表普通用户 # 代表 超级用户</p>
<p>3.linux文件系统</p>
<ul>
<li>目录结构</li>
<li>文件权限分析<br>w ：可写   r： 只读  x：可执行  - ：无权限<br>文件权限<ol>
<li>字符表示法<br>drwxr-xr-x<br>第一个字符 ：文件的类型  - ：普通文件  d：文件夹  c ：串口文件  l ：连接文件<br> 2-4 字符  ： 该文件的属主用户的权限<br>5-7  字符 ： 与属主用户同一组的其他用户的权限<br>8-10 字符 ：  不同组的其他用户的权限</li>
<li>数字表示法</li>
</ol>
 -rw-r–r–   ：文件的默认权限   644<br> drwxr-xr-x   ： 目录的默认权限  755<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>四、linux的常用命令</li>
</ul>
<p>1.注销、关机、重启</p>
<ul>
<li>注销 ：logout ：登出 、exit</li>
<li>关机 ：<br>shutdown - h 时间</li>
<li>h ：关机</li>
<li>时间 ：</li>
</ul>
<ol>
<li>now :马上</li>
<li>12.30 ：指定具体时间</li>
<li>3 ：几分钟以后<br>sudo ： superuser do ：由超级用户来执行该命令<br>要配置sudo 命令 ： 授权 哪些用户能执行哪些命令<br>由超级用户配置 sudo<br>/etc/sudoers<br>sudo shutdown -h now 当前账号：itcast</li>
</ol>
<ul>
<li>重启 ：<br>shutdown -r 时间</li>
<li>r ：restart</li>
</ul>
<p>2.linux基本命令 ：文件操作命令</p>
<ol>
<li>ls   ： 查看目录内容<ul>
<li>l ：查看详细信息</li>
</ul>
</li>
</ol>
<ul>
<li>a ：查看所有文件（隐藏）<br>  man ：manual ： 手工，帮助 ，帮助命令，好比windows help<br>命令： man ls</li>
</ul>
<ol start="2">
<li>mkdir ：创建目录<br>  Desktop：<ul>
<li>java<ul>
<li>JEE ： aa.txt  bb.txt  </li>
<li>Android</li>
</ul>
</li>
</ul>
</li>
<li>cd  切换目录<ul>
<li>cd ..  记得要加空格</li>
</ul>
</li>
</ol>
<ul>
<li>cd ./java  进入当前目录的子目录</li>
<li>cd ../xxx  进入上一级目录的子目录<br> tab ：自动补全</li>
</ul>
<ol start="4">
<li>touch  ：创建一个空白的普通文件<br>touch aa.txt </li>
<li>echo  :把内容重定向到指定的文件中 ，有则打开，无则创建</li>
<li>cat、more  ：查看文件内容<ul>
<li>cat ：查看文件内容</li>
</ul>
</li>
</ol>
<ul>
<li>more ：分页查看文件内容，按空格键换页</li>
</ul>
<ol start="7">
<li>cp、mv、rm   <ul>
<li>cp ：复制<br>cp bj.txt ./java/jee</li>
</ul>
</li>
</ol>
<ul>
<li><p>mv ：剪切、重命名</p>
<ol>
<li>剪切 ：mv aa.txt ../android/</li>
<li>重命名 ：假如剪切的文件 存放在同一个目录中 ，则是重命名<br> mv bb.txt cc.txt</li>
</ol>
</li>
<li><p>rm ：删除文件或者文件夹<br>-f ： 假如要删除的文件不存在，也不提示<br>-i ： 删除前提示 ，默认不删除，要删除，输入y<br>-d ： 删除空白目录<br>-r ：递归删除</p>
</li>
</ul>
<ol start="8">
<li>wc ：word count ：统计字符数<br> 154  233 3418 </li>
</ol>
<ul>
<li>154 ：行数</li>
<li>233 ：单词数</li>
<li>3418 ：字符数<br>命令： wc bj.txt</li>
</ul>
<ol start="9">
<li>ln :创建连接文件<ul>
<li>默认创建的是硬连接，好比复制 ，但是两个文件会同步<br>命令：ln ./java/android/aa.txt  aaa</li>
</ul>
</li>
</ol>
<ul>
<li>s ：创建的是软连接</li>
</ul>
<ol start="10">
<li><p>pwd   ：查看当前目录的绝对路径 </p>
</li>
<li><p>管道命令 |<br>命令： ls -la | wc </p>
</li>
<li><p>重定向</p>
<ul>
<li><blockquote>
<p>:覆盖模式<br>命令：  echo “ww”&gt;aaa</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<ul>
<li><blockquote>
<blockquote>
<p>：追加模式<br>命令： echo “ww”&gt;&gt;aaa</p>
</blockquote>
</blockquote>
</li>
</ul>
<ol start="13">
<li><p>passwd   :设置密码  ，ubuntu默认 root账号是没有开启 ，只要设置root密码即可开启<br>sudo passwd root</p>
</li>
<li><p>su  切换目录<br>su root<br>root用户切换到其他账号不需要密码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62</p>
</li>
<li><p>linux 系统命令</p>
</li>
<li><p>stat ：查看文件的详细信息<br>stat bj.txt</p>
</li>
<li><p>who与whoami<br>who : 查看在线的用户<br>whoami ：查看当前自己的用户</p>
</li>
<li><p>hostname ： 显示主机名<br>hostname</p>
</li>
<li><p>uname ：显示系统信息</p>
</li>
</ol>
<p>-a ：显示完整的系统信息</p>
<p> 5.top ：显示当前耗时的进行的信息 ，每3秒刷新一次<br>     cltr+c 中断<br> 6.ps ：显示当前进程的快照 </p>
<ul>
<li>axu</li>
</ul>
<p> 7.du ：显示文件的大小信息<br> 8.df ：磁盘使用情况  disk free<br> 9.ifconfig ：查看或者配置网卡信息 ，好比windows 的ipconfig<br>    ipv4：32位  2-32次方     ipv6  128位     是 ipv4  2-96次方倍数<br>设置虚拟机ip地址：</p>
<ol>
<li><p>设置vmware的连接方式</p>
<ul>
<li>共享宿主机的ip地址，在网上邻居找不到</li>
<li>桥接方式，需要单独设置ip，可以在网上邻居查找</li>
</ul>
</li>
<li><p>图形界面设置ip地址<br> edit connection –》ipv4–》manual（手工设置）–》add  （ip地址，子网掩码）<br> 3.命令方式设置ip地址<br>静态设置ip：<br>sudo ifconfig eth0 192.168.15.122 netmask 255.255.255.0 </p>
</li>
<li><p>ping  测试与目标主机连接情况</p>
</li>
</ol>
<p> 11.clear  ： 清除屏幕  windows： cls<br> 12.man  ：帮助命令<br>     man 命令<br> 13.kill  ：杀死进程<br>    kill  pid<br> 14.netstat  ：网络连接详细信息</p>
<ol start="15">
<li>useradd <ul>
<li>查看用户信息<br>sudo cat /etc/passwd<br>itcast:x:1000:1000:UbuntuA,,,:/home/itcast:/bin/bash</li>
</ul>
</li>
</ol>
<ul>
<li><p>itcast:用户名</p>
</li>
<li><p>x ：密码 ：已经加密 ，密码存放在  /etc/shadow </p>
</li>
<li><p>1000: 账号id ，userId</p>
</li>
<li><p>1000： 组id ，group id</p>
<ul>
<li>UbuntuA,,,  ：账号描述</li>
<li>/home/itcast ：该账号存放文件的默认位置  ~</li>
</ul>
</li>
<li><p>/bin/bash：该用户的shell脚本的解析方式  ，sh 、bash、rbash</p>
<ul>
<li>创建用户<br>sudo useradd lijun -d  /home/lijun   -s /bin/bash </li>
</ul>
</li>
<li><p>d :指定该用户的home 路径 </p>
</li>
<li><p>s ：该用户的shell解析方式<br>步骤：</p>
<ol>
<li>创建 /home/lijun 目录</li>
<li>执行 useradd 命令</li>
<li>用 passwd 设置密码</li>
<li>su 切换用户<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>五、打包、压缩文件<br>windows ： zip、rar<br>linux ：gz ，bzip，zip</li>
</ol>
</li>
</ul>
<p> 1.tar :打包、拆包命令<br>    tar - cxzjvf  &lt;打包后的文件&gt;   &lt;欲打包的目录&gt;</p>
<ul>
<li><p>c ：创建的一个归档文件 ，即打包文件夹</p>
</li>
<li><p>x ：拆包</p>
</li>
<li><p>z ：以gzip 格式压缩，默认压缩倍数 6倍  （0-9）</p>
</li>
<li><p>j ：以bzip2格式压缩</p>
</li>
<li><p>v ：显示打包或者拆包的文件信息</p>
</li>
<li><p>f ： 后面紧接一个 归档文件</p>
</li>
<li><p>打包文件<br> tar -cvf news.tar  ./java   摘要  </p>
</li>
<li><p>拆包文件<br> tar -xvf news.tar</p>
</li>
</ul>
<p> 2.gzip 、bzip2 压缩与解压<br>    1. 压缩文件<br>  gzip news.tar<br>2. 解压文件<br>  gzip -d news.tar.gz<br>    -d :解压<br> 3.打包及压缩 </p>
<ul>
<li>打包及压缩<br> tar -czvf news.tar.gz ./java</li>
<li>拆包及压解缩<br> tar -xzvf  news.tar.gz<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>六、软件管理<br>windows ： .exe 安装 、卸载<br>安装： mysql.exe cc.exe<br>卸载 ： 该软件唯一的标识 ，包名 alibaba<br>android : <em>.apk 卸载 包名<br>red hat ：</em>.rpm<br>ubuntu : 对debian的升级 *.deb 格式</li>
</ul>
<p> 1.安装软件</p>
<ul>
<li>dpkg ：debian  package<br> 离线安装：<br>安装 ： sudo dpkg - i  &lt;文件名&gt;<br>-i ：install<br>命令：sudo dpkg -i ./tree_1.6.0-1_i386.deb<br>卸载 ： sudo dpkg - r  &lt;包名&gt;<br>-r ：remove<br>  命令：sudo dpkg -r tree</li>
<li>apt-get  ：advance  package  tools<br>　　对dpkg命令的升级，在线安装<br>安装 ： sudo apt-get -install  &lt;包名&gt;<br>卸载 ： sudo apt-get -remove  &lt;包名&gt;</li>
</ul>
<p> 2.vim 软件  ：好比记事本 ，但是比记事本要强大  </p>
<ol>
<li>安装vim</li>
<li>使用vim<br>操作模式：<ol>
<li>一般模式 ，默认进入的一般模式，该模式不能编辑文档 ，只能查看<br>按 i（insert）  进入 插入模式 </li>
<li>编辑模式、插入模式<br> 该模式可以编辑文档，按esc 退出插入模式，进入到一般模式 </li>
<li>命令模式 ：在 一般模式中按：进入命令模式<ul>
<li>q： 安全退出，当没有操作该文档，则直接按q退出vim </li>
</ul>
</li>
</ol>
<ul>
<li>q！：当修改了内容，但是不想保存，则q！强制退出</li>
<li>wq ：保存退出</li>
<li>set number 显示行号</li>
<li>set nonumber 取消行号显示</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shangningsimida.github.io/2021/01/31/linux%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/" data-id="ckkkqujb000006kvfcawfgjn1" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法周报" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/24/%E7%AE%97%E6%B3%95%E5%91%A8%E6%8A%A5/" class="article-date">
  <time class="dt-published" datetime="2021-01-24T09:45:38.229Z" itemprop="datePublished">2021-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>算法周报（1.17-1.24）<br>学习内容：stl<br>list<br>双向链表。只支持双向顺序访问。在list中任何位置进行插入、删除操作速度都很快。</p>
<p>适用于少量读写，大量插入，删除的情况。</p>
<p>用法总结</p>
<p>头文件<br>#include <list><br>声明及初始化<br> list<int> l;<br>容量<br>l.empty();          //判空<br>元素的访问<br>    l.front();                       // 取队头元素<br>    l.back();                        // 取队尾元素<br>修改<br>  l.push_back();                        // 尾后压入元素<br>  l.push_front();                       // 队头压入元素</p>
<p>  l.pop_back();                         // 尾后弹出一个元素<br>  l.pop_front();                        // 队头弹出一个元素</p>
<p>  l.insert(l.begin(), 88);              // 某个位置插入元素(性能好)</p>
<p>  l.remove(2);                          // 删除某个元素(和所给值相同的都删除)<br>  l.erase(–l.end());                   // 删除某个位置的元素(性能好)<br>算法<br>遍历<br>list<int>::iterator it;  </p>
<p>for(it = l.begin(); it!=l.end(); it++)<br>    {<br>        cout&lt;&lt;*it&lt;&lt;endl;<br>    }<br>排序<br>l.sort();           //注意与vector的排序使用方法不一样<br>翻转<br>l.reverse();                                // 倒置所有元素<br>forward_list<br>单向链表。只支持单向顺序访问。在链表的任何位置进行插入、删除操作都很快。</p>
<p>用法总结</p>
<p>与list用法基本一致，用的也不多，先稍微总结下，没有认真总结。</p>
<p>头文件<br>声明及初始化<br>forward_list<int> fl = {1, 2, 3, 4, 5, 6, 7, 8, 9};<br>容量<br>元素的访问<br>    auto prev = fl.before_begin();    // 表示fl的”首前元素”<br>    auto curr = fl.begin();            // 表示fl的第一个元素<br>修改<br>fl.push_front(0);                // 压入元素，该容器没有push_back方法<br>算法<br>遍历<br>排序<br>fl.sort();<br>翻转<br>deque<br>双端队列。支持快速随机访问。在头尾位置插入、删除速度很快。</p>
<p>deque折中了vector和list， 如果你需要随机存取又关心数据的插入和删除，那么可以选择deque。</p>
<p>用法总结</p>
<p>头文件<br>#include <deque><br>声明及初始化<br>deque<int> d1;<br>容量<br>dl.empty()        //判空<br>元素的访问<br>    d1.front();                           // 取队头元素<br>    d1.back();                            // 取队尾元素<br>修改<br>    d1.push_back();                       // 尾后压入元素<br>    d1.push_front(4);                     // 队头压入元素</p>
<pre><code>d1.pop_back();                        // 尾后弹出一个元素
d1.pop_front();                       // 队头弹出一个元素</code></pre>
<p>算法<br>遍历<br>for(it = dl.begin(); it!=dl.end(); it++)   //迭代输出<br>    {<br>        cout&lt;&lt;*it&lt;&lt;endl;<br>    }<br>排序<br>sort(dl.begin(), dl.end());<br>翻转<br>reverse(dl.begin(), dl.end());<br>array<br>固定大小数组。支持快速随机访问。不能添加或者删除元素。</p>
<p>array一般用来代替原生的数组。</p>
<p>用法总结</p>
<p>头文件<br>声明及初始化<br>  array&lt;int, 5&gt; myArray1 = { 1, 2, 3, 4, 5 };    // 定义一个一维数组<br> array&lt;array&lt;int, 2&gt;, 3&gt; myArray2 = {1, 2, 3, 4, 5, 6};    // 定义一个二维数组<br>  array&lt;int, 5&gt; myArray4;                // 此数组并未初始化<br>容量<br>    // array.resize();        // array 不能有改变容器大小的操作，它的效率比vector高<br>元素的访问<br>修改<br>    myArray1.swap(myArray3);// 交换两个数组的的元素<br>    myArray4 = myArray1;    // 支持直接这样赋值，原生的数组不可以这样。它把值全部复制过去，而不是引用<br>    myArray1.assign(0);        // 把myArray1的元素全部置为0<br>算法<br>遍历<br>// 遍历数组元素<br>    for (int i = 0; i &lt; myArray1.size(); ++i)<br>    {<br>        cout &lt;&lt; myArray1[i] &lt;&lt; endl;<br>    }<br>排序<br>翻转<br>string<br>与vector相似的容器，但专门用于保存字符。随机访问快，在尾部插入删除快。</p>
<p>string用于和字符串操作有关的一些情况，也是实际开发中应用最多的。</p>
<p>用法总结</p>
<p>头文件<br>#include <string><br>声明及初始化<br>    string str1 = “Hello Ace”;            // string的几种构造方法<br>    string str2(“Hello World”);<br>    string str3(str1, 6);                // 从str1下标6开始构造， str3 -&gt; Ace<br>容量<br>元素的访问<br>修改<br> string str4 = str2.substr(0, 5);    // 求子串： str4 -&gt; Hello<br> string str5 = str2.substr(6);        // 求子串： str5 -&gt; World<br> string str6 = str2.substr(6, 11);    // 求子串： str6 -&gt; World</p>
<p> string str8 = str2.replace(6, 5, “Game”);    // 替换：str8 -&gt; Hello Game 从位置6开始，删除5个字符，并替换成”Game”</p>
<p> string str9 = str2.append(“, Hello Beauty”);// 追加字符串： str9 -&gt; Hello World, Hello Beauty</p>
<p>  auto pos1 = str1.find(“Ace”);    // 查找字符串:pos1 -&gt; 6 ,返回第一次出现字符串的位置，如果没找着，则返回npos</p>
<p>  int res = str1.compare(“Hello, Ace”);        // 比较字符串： res -&gt; -1, 根据str1是等于、大于还是小于参数指定的字符串， 返回0、整数或者负数<br>算法<br>遍历<br>排序<br>翻转<br>关联容器<br>关联容器支持高效的关键字查询和访问。标准库一共定义了8个关联容器，最主要的类型是map和set。8个容器中，每个容器：</p>
<p>是一个map或者是一个set。map保存关键字-值对；set只保存关键字。<br>要求关键字唯一或者不要求。<br>保持关键字有序或者不保证有序。<br>以下是八个常用的容器类：</p>
<p>set / unordered_set</p>
<p>map / unordered_map</p>
<p>multiset / unordered_multiset<br>multimap / unordered_multimap<br>从名字中就可以看出是否唯一、是否有序，允许重复关键字的容器名字都包含“multi”，不是有序容器的集合都包含“unordered”。</p>
<p>所以set 和map都是有序且无重复元素的。</p>
<p>用法总结<br>set用法</p>
<p>头文件<br>#include <set><br>声明及初始化<br>set<int> s;<br>容量<br>empty() 　　　 //判断set容器是否为空<br>size() 　　　　//返回当前set容器中的元素个数<br>max_size() 　 //返回set容器可能包含的元素最大个数<br>元素的访问<br>begin()     　　 //返回set容器的第一个元素<br>end() 　　　　   //返回set容器的最后一个元素<br>修改<br>erase(iterator)  //删除定位器iterator指向的值<br>erase(first,second)    //删除定位器first和second之间的值<br>erase(key_value)    //删除键值key_value的值</p>
<p>insert(key_value)   //将key_value插入到set中<br>insert(first,second)   //将定位器first到second之间的元素插入到set中<br>6.算法</p>
<p>遍历<br>set<int>::iterator it;  //声明迭代器<br>for(it = s.begin(); it!=s.end(); it++)   //迭代输出<br>    {<br>        cout&lt;&lt;*it&lt;&lt;endl;<br>    }<br>排序<br>set本身就是有序的。<br>翻转<br>reverse(s.begin(), s.end());  //翻转<br>map用法</p>
<p>头文件<br>#include <map><br>声明及初始化<br>map&lt;string,int&gt;   my_Map;<br>容量<br>my_Map.size()           //返回元素数目<br>my_Map.empty()          //判断是否为空<br>my_Map.clear()          //清空所有元素<br>元素的访问<br>int i = my_Map[“a”]; </p>
<p>MY_MAP::iterator   my_Itr;<br>my_Itr.find(“b”);<br>int j = my_Itr-&gt;second;       //first返回键，second返回值</p>
<p>5.修改</p>
<p>//插入数据<br>my_Map[“a”]；        //只插入键，对应的值默认为0<br>my_Map[“a”] = 1;    //同时插入键和值</p>
<p>my_Map.insert(map&lt;string,int&gt;::value_type(“b”,2));<br>my_Map.insert(pair&lt;string,int&gt;(“c”,3));<br>my_Map.insert(make_pair&lt;string,int&gt;(“d”,4)); </p>
<p>//删除数据<br>my_Map.erase(my_Itr);<br>MY_MAP::iterator   my_Itr; </p>
<p>my_Map.erase(“c”);<br>6.算法</p>
<p>遍历<br>map&lt;string,int&gt;::iterator it;  //声明迭代器<br>    for(it = p.begin(); it!=p.end(); it++)   //迭代输出<br>    {<br>        cout&lt;<it->first&lt;<it->second&lt;&lt;endl;<br>    }<br>排序<br>map本身就是有序的<br>翻转</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shangningsimida.github.io/2021/01/24/%E7%AE%97%E6%B3%95%E5%91%A8%E6%8A%A5/" data-id="ckkayiqwg0000b8vfa1j1euf4" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-学习报告" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/23/%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/" class="article-date">
  <time class="dt-published" datetime="2021-01-22T16:17:12.000Z" itemprop="datePublished">2021-01-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/23/%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/">学习报告</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>学习报告（1.17-1.24）<br>学习内容：c++</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>public static void ArraySortTest() {</p>
<pre><code>    int[] ages= &#123;21,27,31,19,50,32,16,25&#125;;
    System.out.println(Arrays.toString(ages));
    //控制比较轮数
    for(int i=1;i&lt;ages.length;i++) &#123;
        //每轮比较多少
        for(int j=0;j&lt;ages.length-i;j++) &#123;
            if(ages[j]&gt;ages[j+1]) &#123;
                int tmp=0;
                tmp=ages[j];
                ages[j]=ages[j+1];
                ages[j+1]=tmp;                    
            &#125;
        &#125;
    &#125;
    System.out.println(Arrays.toString(ages));
&#125;
---</code></pre>
<h2 id="通讯录系统"><a href="#通讯录系统" class="headerlink" title="通讯录系统"></a>通讯录系统</h2><p>#include <iostream><br>#include <algorithm><br>#include <cstring><br>#include <cstdlib><br>#include <string><br>#include <vector><br>#include <fstream><br>#include&lt;windows.h&gt;//后面变颜色用的<br>using namespace std;<br>static int n=0;    //记录输入的数据的个数<br>#define limit 100  //就是通讯录的存储空间<br>class PostCodedress<br>{<br>public:<br>    struct xinxi<br>    {<br>        int id;          //编号顺序<br>        char Name[20];<br>        char Phone[20];<br>        char PostCodedr[100];//地址<br>        char Email[20];<br>        char PostCode[100];//数组的话，注意初始化<br>    }xx;<br>    void zengPostCodedress();  //增加信息；<br>    int cc(char na[]);         //看输入的名字是不是重复；<br>};<br>void PostCodedress::zengPostCodedress()//增加信息的<br>{<br>    for(int i = 1;i&lt;=5;i++)<br>    {<br>        if(i==1)<br>        {<br>            cout&lt;&lt;”请输入联系人的姓名： “&lt;&lt;endl;<br>            cin&gt;&gt;xx.Name;<br>        }<br>        if(i==2)<br>        {<br>            cout&lt;&lt;”请输入联系人的电话号码：  “&lt;&lt;endl;<br>            cin&gt;&gt;xx.Phone;<br>        }<br>        if(i==3)<br>        {<br>            cout&lt;&lt;”请输入联系人的地址： “&lt;&lt;endl;<br>            cin&gt;&gt;xx.PostCodedr;<br>        }<br>        if(i==4)<br>        {<br>            cout&lt;&lt;”请输入联系人的电子邮件:  “&lt;&lt;endl;<br>            cin&gt;&gt;xx.Email;<br>        }<br>        if(i==5)<br>        {<br>            cout&lt;&lt;”请输入联系人的邮编： “&lt;&lt;endl;<br>            cin&gt;&gt;xx.PostCode;<br>        }<br>     }<br>}<br>void color(int a)//设置颜色的，学生特地专门研究了下，windows库函数<br>{<br>    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),a);<br>}<br>int PostCodedress::cc(char na[])<br>{<br>    if(strcmp(na,xx.Name)==0)<br>        return 1;<br>    else return 0;<br>}<br>PostCodedress B[10];<br>class POSTCODEDRESDBOOK:public PostCodedress    //对信息进行排序，并且写进文件，打开文件；<br>{<br>public:<br>    void searchPostCodedress1(char nu[]);//根据电话号码查找联系人；<br>    void searchPostCodedress2(char na[]);//根据姓名查找联系人；<br>    void Save();      //实现保存功能；<br>    void Put();  //增加的信息写入文件<br>    void RePostCode();     //打开文件，显示信息<br>    void display();     //浏览功能，显示信息；<br>    void Delete();    //删除功能；<br>};<br>void POSTCODEDRESDBOOK::searchPostCodedress1(char nu[])//根据电话号码查找联系人；<br>{<br>    int i;<br>    if(n==0)<br>    {<br>        cout&lt;&lt;”查无此人”&lt;&lt;endl;<br>    }else<br>    {<br>        for(i=0;i&lt;n;i++)<br>        {<br>            if(strcmp(nu,B[i].xx.Phone)==0)<br>            {   cout&lt;&lt;B[i].xx.id&lt;&lt;” “&lt;&lt;B[i].xx.Name&lt;&lt;” “&lt;&lt;B[i].xx.Phone&lt;&lt;” “&lt;&lt;B[i].xx.PostCodedr&lt;&lt;” “&lt;&lt;B[i].xx.Email&lt;&lt;” “&lt;&lt;B[i].xx.PostCode&lt;&lt;endl;<br>                break;<br>            }<br>            else if(strcmp(nu,B[i].xx.Phone)!=0 &amp;&amp; i==n-1)<br>            {<br>                cout&lt;&lt;”查无此人”&lt;&lt;endl;<br>                break;<br>            }</p>
<pre><code>    &#125;
&#125;</code></pre>
<p>}<br>void POSTCODEDRESDBOOK::searchPostCodedress2(char na[])//根据姓名查找联系人；<br>{<br>    int i;<br>    if(n==0)<br>    {<br>        cout&lt;&lt;”查无此人”&lt;&lt;endl;<br>    }else<br>    {<br>        for(i=0;i&lt;n;i++)<br>        {<br>            if(strcmp(na,B[i].xx.Name)==0)<br>            {   cout&lt;&lt;B[i].xx.id&lt;&lt;” “&lt;&lt;B[i].xx.Name&lt;&lt;” “&lt;&lt;B[i].xx.Phone&lt;&lt;” “&lt;&lt;B[i].xx.PostCodedr&lt;&lt;” “&lt;&lt;B[i].xx.Email&lt;&lt;” “&lt;&lt;B[i].xx.PostCode&lt;&lt;endl;<br>                break;<br>            }<br>            else if(strcmp(na,B[i].xx.Name)!=0 &amp;&amp; i==n-1)<br>            {<br>                cout&lt;&lt;”查无此人”&lt;&lt;endl;<br>                break;<br>            }</p>
<pre><code>    &#125;
&#125;</code></pre>
<p>}<br>void POSTCODEDRESDBOOK::Save()//实现保存功能；<br>{</p>
<pre><code>ofstream f2(&quot;save_PostCodedress.txt&quot;);
f2.close();
remove(&quot;save_PostCodedress.txt&quot;);
ofstream f3(&quot;save_PostCodedress.txt&quot;);


    for(int i=0;i&lt;n;i++)
    &#123;
        f3&lt;&lt;B[i].xx.id&lt;&lt;&quot; &quot;&lt;&lt;B[i].xx.Name&lt;&lt;&quot; &quot;&lt;&lt;B[i].xx.Phone&lt;&lt;&quot; &quot;&lt;&lt;B[i].xx.PostCodedr&lt;&lt;&quot; &quot;&lt;&lt;B[i].xx.Email&lt;&lt;endl;
    &#125;
    f3.close();</code></pre>
<p>}<br>void POSTCODEDRESDBOOK::Put()//增加的信息写入文件<br>{<br>    ofstream RePostCode(“xcc.txt”); </p>
<pre><code>if(!RePostCode)&#123; 
    cout &lt;&lt; &quot;不能打开文件 &quot;; 
        exit(1); // terminate with error 

&#125; 
    color(23);
    cout&lt;&lt;&quot;这是您输入的第&quot;&lt;&lt;n+1&lt;&lt;&quot;个联系人 &quot;&lt;&lt;endl;
    for(int i=n;;i++)
    &#123;
        if(i==limit)
        &#123;
            cout&lt;&lt;&quot;存储空间已满，可选择删除数据再进行输入&quot;&lt;&lt;endl;
            break;
        &#125;
        B[i].zengPostCodedress();
        for(int j=0;j&lt;n;j++)
        &#123;
            if(B[i].cc(B[j].xx.Name))
            &#123;
                cout&lt;&lt;&quot;数据录入重复&quot;&lt;&lt;endl;
                i=i-1;
                break;
            &#125;
        &#125;

        n++;

        B[i].xx.id=n;
        RePostCode&lt;&lt;B[i].xx.id&lt;&lt;&quot;   &quot;&lt;&lt;B[i].xx.Name&lt;&lt;&quot;    &quot;&lt;&lt;B[i].xx.Phone&lt;&lt;&quot;    &quot;&lt;&lt;B[i].xx.PostCodedr&lt;&lt;&quot;    &quot;&lt;&lt;B[i].xx.Email&lt;&lt;&quot;    &quot;&lt;&lt;B[i].xx.PostCode&lt;&lt;endl;
        char q;
        cout&lt;&lt;&quot;选择是否继续输入（y/n）&quot;&lt;&lt;endl;
        cin&gt;&gt;q;
        if(q==&#39;n&#39;)
            break;
        if(q==&#39;y&#39;)
            continue;

    &#125;
RePostCode.close();</code></pre>
<p>}<br>void POSTCODEDRESDBOOK::RePostCode()//输出文件<br>{<br>    fstream Myfile(“xcc.txt”);<br>    if(!Myfile)    //判断是否成功打开文件<br>    {<br>        cerr&lt;&lt;”open error!”&lt;&lt;endl;<br>        abort();<br>    }<br>    string temp;<br>    while(getline(Myfile,temp))<br>   {<br>        cout&lt;&lt;temp&lt;&lt;endl;<br>   }<br>   Myfile.close();</p>
<p>}<br>void POSTCODEDRESDBOOK::display()//显示当前联系人<br>{<br>    color(03);<br>    cout&lt;&lt;”当前通讯录联系人有:”&lt;&lt;n&lt;&lt;”个     “&lt;&lt;endl&lt;&lt;”通讯录中最多可以添加”&lt;&lt;100-n&lt;&lt;”个联系人”&lt;&lt;endl;<br>    cout&lt;&lt;”联系人如下： “ &lt;&lt;endl;<br>    for(int i=0;i&lt;n;i++)<br>    {<br>        cout&lt;&lt;B[i].xx.id&lt;&lt;”    “&lt;&lt;B[i].xx.Name&lt;&lt;”    “&lt;&lt;B[i].xx.Phone&lt;&lt;”    “&lt;&lt;B[i].xx.PostCodedr&lt;&lt;”    “&lt;&lt;B[i].xx.Email&lt;&lt;”    “&lt;&lt;B[i].xx.PostCode&lt;&lt;endl;<br>    }<br>    cout&lt;&lt;endl;<br>}<br>void POSTCODEDRESDBOOK::Delete()//删除联系人<br>{<br>    char na[20];<br>    cout&lt;&lt;”输入你要删除的人的名字”&lt;&lt;endl;<br>    cin&gt;&gt;na;<br>    int j;<br>    for(int i=0;i&lt;n;i++)<br>    {<br>        if(strcmp(na,B[i].xx.Name)==0)<br>        {<br>            j=i;<br>            break;<br>        }<br>    }</p>
<pre><code>for(int i1=j;i1&lt;n-1;i1++)
&#123;
    B[i1]=B[i1+1];
    B[i1].xx.id=i1;
&#125;
n--;
fstream Myfile(&quot;xcc.txt&quot;);
ofstream f2(&quot;tmp2.txt&quot;); 


for(int i3=0;i3&lt;n;i3++)
        &#123;
            f2&lt;&lt;B[i3].xx.id&lt;&lt;&quot; &quot;&lt;&lt;B[i3].xx.Name&lt;&lt;&quot; &quot;&lt;&lt;B[i3].xx.Phone&lt;&lt;&quot; &quot;&lt;&lt;B[i3].xx.PostCodedr&lt;&lt;&quot; &quot;&lt;&lt;B[i3].xx.Email&lt;&lt;endl;
        &#125;
        Myfile.close();
        f2.close();
        remove(&quot;xcc.txt&quot;);
        rename(&quot;tmp2.txt&quot;,&quot;xcc.txt&quot;);</code></pre>
<p>}<br>int  main()<br>{<br>    POSTCODEDRESDBOOK P;<br>    char Q;<br>    color(423);<br>    cout&lt;&lt;”*************************                      *******************************”&lt;&lt;endl;<br>    color(465);<br>    cout&lt;&lt;”                        ****** 欢 迎 使 用 本 系 统******                      “;<br>    cout&lt;&lt;endl;<br>    color(448);<br>    cout&lt;&lt;”                          *****制作者  xcc****                        “;<br>    fstream f1(“xcc.txt”);<br>    f1.clear();<br>    f1.close();<br>    while(1)<br>    {<br>        POSTCODEDRESDBOOK p;<br>          color(01);<br>          cout&lt;&lt;” “&lt;&lt;endl;<br>        cout&lt;&lt;”                        ********模拟通讯录*******”&lt;&lt;endl;<br>        color(02);<br>        cout&lt;&lt;”                         *****1.添加联系人*****”&lt;&lt;endl;<br>           color(03);<br>        cout&lt;&lt;”                         *****2.联系人列表*****”&lt;&lt;endl;<br>        color(04);<br>        cout&lt;&lt;”                         *****3.查找联系人*****”&lt;&lt;endl;<br>        color(05);<br>        cout&lt;&lt;”                         *****4.删除联系人*****”&lt;&lt;endl;<br>        color(06);<br>        cout&lt;&lt;”                         *****5.通讯录存盘*****”&lt;&lt;endl;<br>        color(07);<br>        cout&lt;&lt;”                         *****6.读出通讯录*****”&lt;&lt;endl;<br>        color(8);<br>        cout&lt;&lt;”                         *****7.退出      *****”&lt;&lt;endl;<br>        color(9);<br>        cout&lt;&lt;”*************************                      *******************************”&lt;&lt;endl;<br>        int q;<br>        cout&lt;&lt;”请选择操作:”&lt;&lt;endl;<br>        cin&gt;&gt;q;<br>        switch(q)<br>        {<br>        case 1:<br>            p.display();<br>            p.Put();<br>            break;<br>        case 2:<br>            p.display();<br>            break;<br>        case 3:<br>            p.display();<br>            char h[11];<br>            cout&lt;&lt;”输入你要按号码（h）查找还是按姓名（m）查找:”&lt;&lt;endl;<br>               char z;<br>               cin&gt;&gt;z;<br>              if(z==’h’)<br>             {<br>                char h[11];<br>                cout&lt;&lt;”输入你要查找的号码:”&lt;&lt;endl;<br>                cin&gt;&gt;h;<br>                p.searchPostCodedress1(h);<br>               }<br>            if(z==’m’)<br>            {<br>                char m[20];<br>                cout&lt;&lt;”输入你要查找的姓名:”&lt;&lt;endl;<br>                cin&gt;&gt;m;<br>                p.searchPostCodedress2(m);<br>            }<br>            break;<br>        case 4:<br>            p.display();<br>            p.Delete();<br>            break;<br>        case 5:<br>            p.display();<br>            p.Save();<br>            break;<br>        case 6:<br>            p.display();<br>            p.RePostCode();<br>            break;<br>        case 7:<br>            break;<br>        }<br>        cout&lt;&lt;”请问是否继续使用系统? 是(y) 否(n)”&lt;&lt;endl;<br>        cin&gt;&gt;Q;<br>        if(Q==’y’)<br>            continue;<br>        if(Q==’n’)<br>            break;<br>    }</p>
<pre><code>return 0;</code></pre>
<h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><p> 一、同步指针：从两端向中间迭代数组。<br> 典型例子 反转数组中的元素。<br>其思想是将第一个元素与末尾进行交换，再向前移动到下一个元素，并不断地交换，直到它到达中间位置。</p>
<p>我们可以同时使用两个指针来完成迭代：一个从第一个元素开始，另一个从最后一个元素开始。持续交换它们所指向的元素，直到这两个指针相遇。</p>
<p>void reverse(int *v, int N) {<br>    int i = 0;<br>    int j = N - 1;<br>    while (i &lt; j) {<br>        swap(v[i], v[j]);<br>        i++;<br>        j–;<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>场景一总结<br>这时你可以使用双指针技巧：<br>一个指针从始端开始，而另一个指针从末端开始。<br>值得注意的是，这种技巧经常在排序数组中使用。</p>
<h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><p>有时，我们可以使用两个不同步的指针来解决问题。</p>
<p>示例<br>让我们从另一个经典问题开始：</p>
<p>给定一个数组和一个值，原地删除该值的所有实例并返回新的长度。<br>1<br>如果我们没有空间复杂度上的限制，那就更容易了。我们可以初始化一个新的数组来存储答案。如果元素不等于给定的目标值，则迭代原始数组并将元素添加到新的数组中。</p>
<p>实际上，它相当于使用了两个指针，一个用于原始数组的迭代，另一个总是指向新数组的最后一个位置。</p>
<p>重新考虑空间限制</p>
<p>现在让我们重新考虑空间受到限制的情况。</p>
<p>我们可以采用类似的策略，我们继续使用两个指针：一个仍然用于迭代，而第二个指针总是指向下一次添加的位置。</p>
<p>以下代码可以供你参考：</p>
<p>int removeElement(vector<int>&amp; nums, int val) {<br>    int k = 0;<br>    for (int i = 0; i &lt; nums.size(); ++i) {<br>        if (nums[i] != val) {<br>            nums[k] = nums[i];<br>            ++k;<br>        }<br>    }<br>    return k;<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>在上面的例子中，我们使用两个指针，一个快指针 i 和一个慢指针 k 。i 每次移动一步，而 k 只在添加新的被需要的值时才移动一步。</p>
<p>场景二总结<br>这是你需要使用双指针技巧的一种非常常见的情况：</p>
<p>同时有一个慢指针和一个快指针。<br>解决这类问题的关键是</p>
<p>确定两个指针的移动策略。<br>与前一个场景类似，你有时可能需要在使用双指针技巧之前对数组进行排序，也可能需要运用贪心想法来决定你的运动策略。</p>
<h2 id="读文件-写文件"><a href="#读文件-写文件" class="headerlink" title="读文件 写文件"></a>读文件 写文件</h2><p>#include <iostream><br>#include <fstream><br>#include <cstdlib> //qsort在此头文件中声明<br>using namespace std;<br>const int MAX_NUM = 1000;<br>int a[MAX_NUM]; //存放文件中读入的整数<br>int MyCompare(const void * e1, const void * e2)<br>{ //用于qsort的比较函数<br>     return *((int *)e1) - *((int *)e2);<br>}<br>int main()<br>{<br>    int total = 0;//读入的整数个数<br>    ifstream srcFile(“in.txt”,ios::in); //以文本模式打开in.txt备读<br>    if(!srcFile) { //打开失败<br>        cout &lt;&lt; “error opening source file.” &lt;&lt; endl;<br>        return 0;<br>    }<br>    ofstream destFile(“out.txt”,ios::out); //以文本模式打开out.txt备写<br>    if(!destFile) {<br>        srcFile.close(); //程序结束前不能忘记关闭以前打开过的文件<br>        cout &lt;&lt; “error opening destination file.” &lt;&lt; endl;<br>        return 0;<br>    }<br>    int x;<br>    while(srcFile &gt;&gt; x) //可以像用cin那样用ifstream对象<br>        a[total++] = x;<br>    qsort(a,total,sizeof(int),MyCompare); //排序<br>    for(int i = 0;i &lt; total; ++i)<br>        destFile &lt;&lt; a[i] &lt;&lt; “ “; //可以像用cout那样用ofstream对象<br>    destFile.close();<br>    srcFile.close();<br>    return 0;<br>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shangningsimida.github.io/2021/01/23/%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/" data-id="ckk8hpvnc0000ewvfcflj2ntc" data-title="学习报告" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/22/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-01-22T15:53:07.362Z" itemprop="datePublished">2021-01-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/22/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shangningsimida.github.io/2021/01/22/hello-world/" data-id="ckk8gs1mu000078vf2d250abh" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/31/%E7%AE%97%E6%B3%95%E6%8A%A5%E5%91%8A/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/01/31/linux%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/01/24/%E7%AE%97%E6%B3%95%E5%91%A8%E6%8A%A5/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/01/23/%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/">学习报告</a>
          </li>
        
          <li>
            <a href="/2021/01/22/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 shangningsimida<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>